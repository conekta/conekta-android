/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.conekta

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.conekta.model.BlacklistRuleResponse
import io.conekta.model.CreateRiskRulesData
import io.conekta.model.DeletedBlacklistRuleResponse
import io.conekta.model.DeletedWhitelistRuleResponse
import io.conekta.model.Error
import io.conekta.model.RiskRulesList
import io.conekta.model.WhitelistlistRuleResponse

import com.google.gson.annotations.SerializedName

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class AntifraudApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.conekta.io")
        }
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageCreateRuleBlacklist(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Create blacklisted rule
     * 
     * @param createRiskRulesData requested field for blacklist rule
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return BlacklistRuleResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRuleBlacklist(createRiskRulesData: CreateRiskRulesData, acceptLanguage: AcceptLanguageCreateRuleBlacklist? = AcceptLanguageCreateRuleBlacklist.es) : BlacklistRuleResponse {
        val localVarResponse = createRuleBlacklistWithHttpInfo(createRiskRulesData = createRiskRulesData, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlacklistRuleResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create blacklisted rule
     * 
     * @param createRiskRulesData requested field for blacklist rule
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return ApiResponse<BlacklistRuleResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRuleBlacklistWithHttpInfo(createRiskRulesData: CreateRiskRulesData, acceptLanguage: AcceptLanguageCreateRuleBlacklist?) : ApiResponse<BlacklistRuleResponse?> {
        val localVariableConfig = createRuleBlacklistRequestConfig(createRiskRulesData = createRiskRulesData, acceptLanguage = acceptLanguage)

        return request<CreateRiskRulesData, BlacklistRuleResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRuleBlacklist
     *
     * @param createRiskRulesData requested field for blacklist rule
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return RequestConfig
     */
    fun createRuleBlacklistRequestConfig(createRiskRulesData: CreateRiskRulesData, acceptLanguage: AcceptLanguageCreateRuleBlacklist?) : RequestConfig<CreateRiskRulesData> {
        val localVariableBody = createRiskRulesData
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/antifraud/blacklists",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageCreateRuleWhitelist(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Create whitelisted rule
     * 
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param createRiskRulesData  (optional)
     * @return WhitelistlistRuleResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRuleWhitelist(acceptLanguage: AcceptLanguageCreateRuleWhitelist? = AcceptLanguageCreateRuleWhitelist.es, createRiskRulesData: CreateRiskRulesData? = null) : WhitelistlistRuleResponse {
        val localVarResponse = createRuleWhitelistWithHttpInfo(acceptLanguage = acceptLanguage, createRiskRulesData = createRiskRulesData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WhitelistlistRuleResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create whitelisted rule
     * 
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param createRiskRulesData  (optional)
     * @return ApiResponse<WhitelistlistRuleResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRuleWhitelistWithHttpInfo(acceptLanguage: AcceptLanguageCreateRuleWhitelist?, createRiskRulesData: CreateRiskRulesData?) : ApiResponse<WhitelistlistRuleResponse?> {
        val localVariableConfig = createRuleWhitelistRequestConfig(acceptLanguage = acceptLanguage, createRiskRulesData = createRiskRulesData)

        return request<CreateRiskRulesData, WhitelistlistRuleResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRuleWhitelist
     *
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param createRiskRulesData  (optional)
     * @return RequestConfig
     */
    fun createRuleWhitelistRequestConfig(acceptLanguage: AcceptLanguageCreateRuleWhitelist?, createRiskRulesData: CreateRiskRulesData?) : RequestConfig<CreateRiskRulesData> {
        val localVariableBody = createRiskRulesData
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/antifraud/whitelists",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageDeleteRuleBlacklist(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Delete blacklisted rule
     * 
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return DeletedBlacklistRuleResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRuleBlacklist(id: kotlin.String, acceptLanguage: AcceptLanguageDeleteRuleBlacklist? = AcceptLanguageDeleteRuleBlacklist.es, xChildCompanyId: kotlin.String? = null) : DeletedBlacklistRuleResponse {
        val localVarResponse = deleteRuleBlacklistWithHttpInfo(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeletedBlacklistRuleResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete blacklisted rule
     * 
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<DeletedBlacklistRuleResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRuleBlacklistWithHttpInfo(id: kotlin.String, acceptLanguage: AcceptLanguageDeleteRuleBlacklist?, xChildCompanyId: kotlin.String?) : ApiResponse<DeletedBlacklistRuleResponse?> {
        val localVariableConfig = deleteRuleBlacklistRequestConfig(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<Unit, DeletedBlacklistRuleResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRuleBlacklist
     *
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun deleteRuleBlacklistRequestConfig(id: kotlin.String, acceptLanguage: AcceptLanguageDeleteRuleBlacklist?, xChildCompanyId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/antifraud/blacklists/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageDeleteRuleWhitelist(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Delete whitelisted rule
     * 
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return DeletedWhitelistRuleResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRuleWhitelist(id: kotlin.String, acceptLanguage: AcceptLanguageDeleteRuleWhitelist? = AcceptLanguageDeleteRuleWhitelist.es, xChildCompanyId: kotlin.String? = null) : DeletedWhitelistRuleResponse {
        val localVarResponse = deleteRuleWhitelistWithHttpInfo(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeletedWhitelistRuleResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete whitelisted rule
     * 
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<DeletedWhitelistRuleResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRuleWhitelistWithHttpInfo(id: kotlin.String, acceptLanguage: AcceptLanguageDeleteRuleWhitelist?, xChildCompanyId: kotlin.String?) : ApiResponse<DeletedWhitelistRuleResponse?> {
        val localVariableConfig = deleteRuleWhitelistRequestConfig(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<Unit, DeletedWhitelistRuleResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRuleWhitelist
     *
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun deleteRuleWhitelistRequestConfig(id: kotlin.String, acceptLanguage: AcceptLanguageDeleteRuleWhitelist?, xChildCompanyId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/antifraud/whitelists/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageGetRuleBlacklist(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Get list of blacklisted rules
     * Return all rules
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return RiskRulesList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRuleBlacklist(acceptLanguage: AcceptLanguageGetRuleBlacklist? = AcceptLanguageGetRuleBlacklist.es) : RiskRulesList {
        val localVarResponse = getRuleBlacklistWithHttpInfo(acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RiskRulesList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get list of blacklisted rules
     * Return all rules
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return ApiResponse<RiskRulesList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRuleBlacklistWithHttpInfo(acceptLanguage: AcceptLanguageGetRuleBlacklist?) : ApiResponse<RiskRulesList?> {
        val localVariableConfig = getRuleBlacklistRequestConfig(acceptLanguage = acceptLanguage)

        return request<Unit, RiskRulesList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRuleBlacklist
     *
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return RequestConfig
     */
    fun getRuleBlacklistRequestConfig(acceptLanguage: AcceptLanguageGetRuleBlacklist?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/antifraud/blacklists",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageGetRuleWhitelist(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Get a list of whitelisted rules
     * Return all rules
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return RiskRulesList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRuleWhitelist(acceptLanguage: AcceptLanguageGetRuleWhitelist? = AcceptLanguageGetRuleWhitelist.es) : RiskRulesList {
        val localVarResponse = getRuleWhitelistWithHttpInfo(acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RiskRulesList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get a list of whitelisted rules
     * Return all rules
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return ApiResponse<RiskRulesList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRuleWhitelistWithHttpInfo(acceptLanguage: AcceptLanguageGetRuleWhitelist?) : ApiResponse<RiskRulesList?> {
        val localVariableConfig = getRuleWhitelistRequestConfig(acceptLanguage = acceptLanguage)

        return request<Unit, RiskRulesList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRuleWhitelist
     *
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return RequestConfig
     */
    fun getRuleWhitelistRequestConfig(acceptLanguage: AcceptLanguageGetRuleWhitelist?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/antifraud/whitelists",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
