/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.conekta

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.conekta.model.Error
import io.conekta.model.GetOrdersResponse
import io.conekta.model.OrderCaptureRequest
import io.conekta.model.OrderRefundRequest
import io.conekta.model.OrderRequest
import io.conekta.model.OrderResponse
import io.conekta.model.OrderUpdateRequest

import com.google.gson.annotations.SerializedName

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class OrdersApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.conekta.io")
        }
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageCancelOrder(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Cancel Order
     * Cancel an order that has been previously created.
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cancelOrder(id: kotlin.String, acceptLanguage: AcceptLanguageCancelOrder? = AcceptLanguageCancelOrder.es, xChildCompanyId: kotlin.String? = null) : OrderResponse {
        val localVarResponse = cancelOrderWithHttpInfo(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Cancel Order
     * Cancel an order that has been previously created.
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cancelOrderWithHttpInfo(id: kotlin.String, acceptLanguage: AcceptLanguageCancelOrder?, xChildCompanyId: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = cancelOrderRequestConfig(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cancelOrder
     *
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun cancelOrderRequestConfig(id: kotlin.String, acceptLanguage: AcceptLanguageCancelOrder?, xChildCompanyId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orders/{id}/cancel".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageCreateOrder(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Create order
     * Create a new order.
     * @param orderRequest requested field for order
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrder(orderRequest: OrderRequest, acceptLanguage: AcceptLanguageCreateOrder? = AcceptLanguageCreateOrder.es, xChildCompanyId: kotlin.String? = null) : OrderResponse {
        val localVarResponse = createOrderWithHttpInfo(orderRequest = orderRequest, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create order
     * Create a new order.
     * @param orderRequest requested field for order
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOrderWithHttpInfo(orderRequest: OrderRequest, acceptLanguage: AcceptLanguageCreateOrder?, xChildCompanyId: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = createOrderRequestConfig(orderRequest = orderRequest, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<OrderRequest, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrder
     *
     * @param orderRequest requested field for order
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun createOrderRequestConfig(orderRequest: OrderRequest, acceptLanguage: AcceptLanguageCreateOrder?, xChildCompanyId: kotlin.String?) : RequestConfig<OrderRequest> {
        val localVariableBody = orderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageGetOrderById(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Get Order
     * Info for a specific order
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOrderById(id: kotlin.String, acceptLanguage: AcceptLanguageGetOrderById? = AcceptLanguageGetOrderById.es, xChildCompanyId: kotlin.String? = null) : OrderResponse {
        val localVarResponse = getOrderByIdWithHttpInfo(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Order
     * Info for a specific order
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOrderByIdWithHttpInfo(id: kotlin.String, acceptLanguage: AcceptLanguageGetOrderById?, xChildCompanyId: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = getOrderByIdRequestConfig(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrderById
     *
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun getOrderByIdRequestConfig(id: kotlin.String, acceptLanguage: AcceptLanguageGetOrderById?, xChildCompanyId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orders/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageGetOrders(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Get a list of Orders
     * Get order details in the form of a list
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @param limit The numbers of items to return, the maximum value is 250 (optional, default to 20)
     * @param search General order search, e.g. by mail, reference etc. (optional)
     * @param next next page (optional)
     * @param previous previous page (optional)
     * @param paymentStatus Filters by order status (optional)
     * @param lastPaymentInfoStatus Filters by last payment info status (optional)
     * @param createdAt created equal to (optional)
     * @param createdAtGte created at greater than or equal to (optional)
     * @param createdAtLte created at less than or equal to (optional)
     * @param updatedAtGte updated at greater than or equal to (optional)
     * @param updatedAtLte updated at less than or equal to (optional)
     * @return GetOrdersResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOrders(acceptLanguage: AcceptLanguageGetOrders? = AcceptLanguageGetOrders.es, xChildCompanyId: kotlin.String? = null, limit: kotlin.Int? = 20, search: kotlin.String? = null, next: kotlin.String? = null, previous: kotlin.String? = null, paymentStatus: kotlin.String? = null, lastPaymentInfoStatus: kotlin.String? = null, createdAt: kotlin.Long? = null, createdAtGte: kotlin.Long? = null, createdAtLte: kotlin.Long? = null, updatedAtGte: kotlin.Long? = null, updatedAtLte: kotlin.Long? = null) : GetOrdersResponse {
        val localVarResponse = getOrdersWithHttpInfo(acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId, limit = limit, search = search, next = next, previous = previous, paymentStatus = paymentStatus, lastPaymentInfoStatus = lastPaymentInfoStatus, createdAt = createdAt, createdAtGte = createdAtGte, createdAtLte = createdAtLte, updatedAtGte = updatedAtGte, updatedAtLte = updatedAtLte)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOrdersResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get a list of Orders
     * Get order details in the form of a list
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @param limit The numbers of items to return, the maximum value is 250 (optional, default to 20)
     * @param search General order search, e.g. by mail, reference etc. (optional)
     * @param next next page (optional)
     * @param previous previous page (optional)
     * @param paymentStatus Filters by order status (optional)
     * @param lastPaymentInfoStatus Filters by last payment info status (optional)
     * @param createdAt created equal to (optional)
     * @param createdAtGte created at greater than or equal to (optional)
     * @param createdAtLte created at less than or equal to (optional)
     * @param updatedAtGte updated at greater than or equal to (optional)
     * @param updatedAtLte updated at less than or equal to (optional)
     * @return ApiResponse<GetOrdersResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOrdersWithHttpInfo(acceptLanguage: AcceptLanguageGetOrders?, xChildCompanyId: kotlin.String?, limit: kotlin.Int?, search: kotlin.String?, next: kotlin.String?, previous: kotlin.String?, paymentStatus: kotlin.String?, lastPaymentInfoStatus: kotlin.String?, createdAt: kotlin.Long?, createdAtGte: kotlin.Long?, createdAtLte: kotlin.Long?, updatedAtGte: kotlin.Long?, updatedAtLte: kotlin.Long?) : ApiResponse<GetOrdersResponse?> {
        val localVariableConfig = getOrdersRequestConfig(acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId, limit = limit, search = search, next = next, previous = previous, paymentStatus = paymentStatus, lastPaymentInfoStatus = lastPaymentInfoStatus, createdAt = createdAt, createdAtGte = createdAtGte, createdAtLte = createdAtLte, updatedAtGte = updatedAtGte, updatedAtLte = updatedAtLte)

        return request<Unit, GetOrdersResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrders
     *
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @param limit The numbers of items to return, the maximum value is 250 (optional, default to 20)
     * @param search General order search, e.g. by mail, reference etc. (optional)
     * @param next next page (optional)
     * @param previous previous page (optional)
     * @param paymentStatus Filters by order status (optional)
     * @param lastPaymentInfoStatus Filters by last payment info status (optional)
     * @param createdAt created equal to (optional)
     * @param createdAtGte created at greater than or equal to (optional)
     * @param createdAtLte created at less than or equal to (optional)
     * @param updatedAtGte updated at greater than or equal to (optional)
     * @param updatedAtLte updated at less than or equal to (optional)
     * @return RequestConfig
     */
    fun getOrdersRequestConfig(acceptLanguage: AcceptLanguageGetOrders?, xChildCompanyId: kotlin.String?, limit: kotlin.Int?, search: kotlin.String?, next: kotlin.String?, previous: kotlin.String?, paymentStatus: kotlin.String?, lastPaymentInfoStatus: kotlin.String?, createdAt: kotlin.Long?, createdAtGte: kotlin.Long?, createdAtLte: kotlin.Long?, updatedAtGte: kotlin.Long?, updatedAtLte: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (next != null) {
                    put("next", listOf(next.toString()))
                }
                if (previous != null) {
                    put("previous", listOf(previous.toString()))
                }
                if (paymentStatus != null) {
                    put("payment_status", listOf(paymentStatus.toString()))
                }
                if (lastPaymentInfoStatus != null) {
                    put("last_payment_info.status", listOf(lastPaymentInfoStatus.toString()))
                }
                if (createdAt != null) {
                    put("created_at", listOf(createdAt.toString()))
                }
                if (createdAtGte != null) {
                    put("created_at.gte", listOf(createdAtGte.toString()))
                }
                if (createdAtLte != null) {
                    put("created_at.lte", listOf(createdAtLte.toString()))
                }
                if (updatedAtGte != null) {
                    put("updated_at.gte", listOf(updatedAtGte.toString()))
                }
                if (updatedAtLte != null) {
                    put("updated_at.lte", listOf(updatedAtLte.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageOrderCancelRefund(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Cancel Refund
     * A refunded order describes the items, amount, and reason an order is being refunded.
     * @param id Identifier of the resource
     * @param refundId refund identifier
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderCancelRefund(id: kotlin.String, refundId: kotlin.String, acceptLanguage: AcceptLanguageOrderCancelRefund? = AcceptLanguageOrderCancelRefund.es, xChildCompanyId: kotlin.String? = null) : OrderResponse {
        val localVarResponse = orderCancelRefundWithHttpInfo(id = id, refundId = refundId, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Cancel Refund
     * A refunded order describes the items, amount, and reason an order is being refunded.
     * @param id Identifier of the resource
     * @param refundId refund identifier
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderCancelRefundWithHttpInfo(id: kotlin.String, refundId: kotlin.String, acceptLanguage: AcceptLanguageOrderCancelRefund?, xChildCompanyId: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = orderCancelRefundRequestConfig(id = id, refundId = refundId, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderCancelRefund
     *
     * @param id Identifier of the resource
     * @param refundId refund identifier
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun orderCancelRefundRequestConfig(id: kotlin.String, refundId: kotlin.String, acceptLanguage: AcceptLanguageOrderCancelRefund?, xChildCompanyId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/orders/{id}/refunds/{refund_id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"refund_id"+"}", encodeURIComponent(refundId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageOrderRefund(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Refund Order
     * A refunded order describes the items, amount, and reason an order is being refunded.
     * @param id Identifier of the resource
     * @param orderRefundRequest requested field for a refund
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderRefund(id: kotlin.String, orderRefundRequest: OrderRefundRequest, acceptLanguage: AcceptLanguageOrderRefund? = AcceptLanguageOrderRefund.es, xChildCompanyId: kotlin.String? = null) : OrderResponse {
        val localVarResponse = orderRefundWithHttpInfo(id = id, orderRefundRequest = orderRefundRequest, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Refund Order
     * A refunded order describes the items, amount, and reason an order is being refunded.
     * @param id Identifier of the resource
     * @param orderRefundRequest requested field for a refund
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderRefundWithHttpInfo(id: kotlin.String, orderRefundRequest: OrderRefundRequest, acceptLanguage: AcceptLanguageOrderRefund?, xChildCompanyId: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = orderRefundRequestConfig(id = id, orderRefundRequest = orderRefundRequest, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId)

        return request<OrderRefundRequest, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderRefund
     *
     * @param id Identifier of the resource
     * @param orderRefundRequest requested field for a refund
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @return RequestConfig
     */
    fun orderRefundRequestConfig(id: kotlin.String, orderRefundRequest: OrderRefundRequest, acceptLanguage: AcceptLanguageOrderRefund?, xChildCompanyId: kotlin.String?) : RequestConfig<OrderRefundRequest> {
        val localVariableBody = orderRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orders/{id}/refunds".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageOrdersCreateCapture(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Capture Order
     * Processes an order that has been previously authorized.
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @param orderCaptureRequest requested fields for capture order (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ordersCreateCapture(id: kotlin.String, acceptLanguage: AcceptLanguageOrdersCreateCapture? = AcceptLanguageOrdersCreateCapture.es, xChildCompanyId: kotlin.String? = null, orderCaptureRequest: OrderCaptureRequest? = null) : OrderResponse {
        val localVarResponse = ordersCreateCaptureWithHttpInfo(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId, orderCaptureRequest = orderCaptureRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Capture Order
     * Processes an order that has been previously authorized.
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @param orderCaptureRequest requested fields for capture order (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ordersCreateCaptureWithHttpInfo(id: kotlin.String, acceptLanguage: AcceptLanguageOrdersCreateCapture?, xChildCompanyId: kotlin.String?, orderCaptureRequest: OrderCaptureRequest?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = ordersCreateCaptureRequestConfig(id = id, acceptLanguage = acceptLanguage, xChildCompanyId = xChildCompanyId, orderCaptureRequest = orderCaptureRequest)

        return request<OrderCaptureRequest, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ordersCreateCapture
     *
     * @param id Identifier of the resource
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @param xChildCompanyId In the case of a holding company, the company id of the child company to which will process the request. (optional)
     * @param orderCaptureRequest requested fields for capture order (optional)
     * @return RequestConfig
     */
    fun ordersCreateCaptureRequestConfig(id: kotlin.String, acceptLanguage: AcceptLanguageOrdersCreateCapture?, xChildCompanyId: kotlin.String?, orderCaptureRequest: OrderCaptureRequest?) : RequestConfig<OrderCaptureRequest> {
        val localVariableBody = orderCaptureRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xChildCompanyId?.apply { localVariableHeaders["X-Child-Company-Id"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orders/{id}/capture".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter acceptLanguage
     */
     enum class AcceptLanguageUpdateOrder(val value: kotlin.String) {
         @SerializedName(value = "es") es("es"),
         @SerializedName(value = "en") en("en")
     }

    /**
     * Update Order
     * Update an existing Order.
     * @param id Identifier of the resource
     * @param orderUpdateRequest requested field for an order
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateOrder(id: kotlin.String, orderUpdateRequest: OrderUpdateRequest, acceptLanguage: AcceptLanguageUpdateOrder? = AcceptLanguageUpdateOrder.es) : OrderResponse {
        val localVarResponse = updateOrderWithHttpInfo(id = id, orderUpdateRequest = orderUpdateRequest, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Order
     * Update an existing Order.
     * @param id Identifier of the resource
     * @param orderUpdateRequest requested field for an order
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateOrderWithHttpInfo(id: kotlin.String, orderUpdateRequest: OrderUpdateRequest, acceptLanguage: AcceptLanguageUpdateOrder?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = updateOrderRequestConfig(id = id, orderUpdateRequest = orderUpdateRequest, acceptLanguage = acceptLanguage)

        return request<OrderUpdateRequest, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateOrder
     *
     * @param id Identifier of the resource
     * @param orderUpdateRequest requested field for an order
     * @param acceptLanguage Use for knowing which language to use (optional, default to es)
     * @return RequestConfig
     */
    fun updateOrderRequestConfig(id: kotlin.String, orderUpdateRequest: OrderUpdateRequest, acceptLanguage: AcceptLanguageUpdateOrder?) : RequestConfig<OrderUpdateRequest> {
        val localVariableBody = orderUpdateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/vnd.conekta-v2.1.0+json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/orders/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
